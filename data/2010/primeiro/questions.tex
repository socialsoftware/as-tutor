
{\Large 

  \textbf {Warning:} In the questions that follow there are pieces of
  text that were obtained directly from available sources in the
  Internet (such as Wikipedia, for example), without changing the
  terminology used to adapt it to that used in this course. Therefore,
  \textbf {it may happen that the terminology used in those pieces of
    text is different from that used in the course. For example, the
    use of \emph{component} to refer to other types of software
    elements.  Please take this into account in your responses.}

}



%1
\newcommand{\qVistasDesempenho}{
\begin{ClosedQuestion}
  Suppose that there are certain performance requirements for a
  system, and that you want to show to the stakeholders of the system
  that the software architecture that you designed meet those
  requirements.  To do this

  \optionA{It makes no sense to use views of the module viewtype, as
    they give only a static view of the system}
  \optionB{You should use only views of the component-and-connector
    viewtype, which describe the dynamic aspects of the system}
   \optionC{You may need to use views of the three viewtypes}
   \optionD{The only views that are relevant to performance
     requirements are views of the Deployment style}}

    \putOptions
\end{ClosedQuestion}
}


%2
\newcommand{\qAtrQualNegocio}{
\begin{ClosedQuestion}
  There are other factors that affect the development of a software
  system, besides its functional requirements and quality attributes.
  For example, factors such as budget or available time.  These factors

    \optionA{Influence the software development process and its
   management, but not the software architecture of the system under
   development}
    \optionB{Should be captured in scenarios, as the requirements for
   quality attributes, and be taken into account in the design of the
   software architecture}
    \optionC{Are important to determine the feasibility of the system,
   but once we reach the conclusion that the system can be developed
   with these restrictions, software architecture no longer depends on
   these factors}
    \optionD{Are not one of the influences of the software architecture
   in the Architecture Business Cycle}

    \putOptions
\end{ClosedQuestion}
}


%3
\newcommand{\qReutilizar}{
\begin{ClosedQuestion}
  Suppose that you are developing a new software system and that you
  want some part of the system's functionality to be easily reusable
  in future systems.  Which of the following architectural styles are
  more suitable to show that the system architecture meets this
  requirement.
  
    \optionA{The \emph{decomposition} and \emph{uses} styles, which
    allow us to show how dependent a certain module is of other parts
    of the system}
    \optionB{The \emph{implementation} style, which allows us to know
    where are the artifacts that implement a certain module}
    \optionC{The \emph{layers} style, which allows us to show that the
    structure of our system is composed of various modules that may be
    easily reused in other systems}
    \optionD{The \emph{client-server} and \emph{deployment} styles,
    which allow us to isolate the required functionality in a
    component that executes autonomously and, thus, reusable in other systems}

    \putOptions
\end{ClosedQuestion}
}


%4
\newcommand{\qTresTiposVista}{
\begin{ClosedQuestion}
  According to the SEI model, there are three different architectural
  viewtypes that are usually necessary to describe completely a
  software architecture.

    \optionA{Those three viewtypes complement each other, but they are
    completely independent, showing different aspects that have no
    relation among them}
    \optionB{The module and component-and-connector viewtypes are
    independent of one another, but the allocation viewtype depends on
    the first two}
    \optionC{Each viewtype uses different software elements, such as
    modules or components, so it does not make sense to talk about
    relationships among these viewtypes}
    \optionD{Even though each viewtype addresses different aspects of a
    system, there are relationships among all of them}

    \putOptions
\end{ClosedQuestion}
}


%5
\newcommand{\qModificabilidadeCamadas}{
\begin{ClosedQuestion}
  In a layered architecture composed by four layers, where the topmost
  layer is the layer number 1 and the bottommost layer is the layer
  number 4, which of the layers is more modifiable?

    \optionA{Layer 1}
    \optionB{Layer 4}
    \optionC{In a layered architecture all layers are equally modifiable}
    \optionD{Modifiability is not made easier by a layered architecture}

    \putOptions
\end{ClosedQuestion}
}


%6
\newcommand{\qUtilidadeArquitectura}{
\begin{ClosedQuestion}
  Designing the software architecture for a complex system

    \optionA{Is useful only if done (even if only partially) before the
    system's implementation is concluded, given that the architecture
    is used for restricting the implementation}
    \optionB{Is useful only if done (even if only partially) before the 
    system's implementation is concluded, because if the system is
    already implemented, its implementation uniquely determines the
    architecture}
    \optionC{Is useful only if done (even if only partially) before the 
    system passes all of the acceptance tests by the client, given
    that no more requirements changes will take place after that time}
    \optionD{Is useful even if the implementation is concluded and the
    system has entered the maintenance phase}

    \putOptions
\end{ClosedQuestion}
}


%7
\newcommand{\qArchitecturalDrivers}{
\begin{ClosedQuestion}
  The requirements for complex systems are usually very numerous and
  conflicting among them, making it impossible to satisfy all the
  requirements in a given implementation of the system.  Therefore,
  the recommended process for making the design of a software
  architecture involves the identification of the \emph{architectural
    drivers} that will shape the design of architecture.  These
  \emph{architectural drivers} should be chosen so that they are

    \optionA{A subset of the requirements that do not have conflicts
     among them and that correspond to the most important business
     goals}
     \optionB{A subset of the requirements that have many conflicts
     among them and for which you need to find tradeoffs  early in the
     design process}
     \optionC{A subset of the requirements that correspond to the 
     most important business goals, regardless of whether they have
     conflicts among them or not}
    \optionD{A subset of the requirements that is chosen
     exclusively by the architect by taking into account their
     influence on the system's architecture}

    \putOptions
\end{ClosedQuestion}
}


%8
\newcommand{\qArqEmailMTA}{
\begin{ClosedQuestion}
  The email system is composed of various types of components playing
  different roles.  For example, to send an email, a user can use a
  program such as Microsoft Outlook or Mozilla Thunderbird,
  generically designed a \emph{mail user agent} (MUA), to compose his
  message and send it.  To send the message, the MUA typically
  connects to a \emph{mail transfer agent} (MTA) that receives the
  message, analyzes the message's headers to determine the recipients
  and, after querying the DNS system to determine the MTA responsible
  for each recipient, it connects to the MTAs responsible for the
  destination addresses to deliver the message.  Each of these MTAs
  receives the message and stores it locally or forwards it to others
  MTAs (for example, when there are forwards or aliases configured, or
  when the MTA that receives the message is not the ultimately
  responsible for the email address of the recipient).

  Given this simplified description of the operation of the email
  system, which of the following architectural styles is more
  appropriate to represent the pattern of interaction between the
  MTAs?

    \optionA{The \emph{Peer-to-Peer} style}
    \optionB{The \emph{Shared data} style}
    \optionC{The \emph{Client-Server} style}
    \optionD{The \emph{Publish-subscribe} style}

    \putOptions
\end{ClosedQuestion}
}


%9
\newcommand{\qArqEmailIMAP}{
\begin{ClosedQuestion}
  Considering yet the example of the email system, MUAs are used not
  only to compose and to send messages, but also for users to read the
  email messages sent to them. For this, the MUAs have to get those
  messages from the component that stores them to show them to the
  user.  Two different ways of doing this is by using the POP and IMAP
  protocols.  In the first case, messages are moved from the POP
  server to the user's computer.  In second case, the messages are
  always stored on the IMAP server, allowing the user to access email
  from different computers, as long as they are able to connect to the
  same IMAP server.

  Which of the following architectural styles is more appropriate to
  represent the pattern of interaction between the MUAs and a IMAP
  server?

    \optionA{The \emph{Communicating Processes} style}
    \optionB{The \emph{Pipes-and-filters} style}
    \optionC{The \emph{Peer-to-Peer} style}
    \optionD{The \emph{Shared data} style}

    \putOptions
\end{ClosedQuestion}
}


%10
\newcommand{\qXBoardChess}{
\begin{ClosedQuestion}
  Given the complexity of building a good automatic Chess player,
  programs that play chess usually make use of existing chess engines,
  as shown by the following excerpt from Wikipedia:
 \begin{quote}
    A chess engine is a computer program that can play the game of
    chess.

    Most chess engines do not have their own graphical user interface
    (GUI) but are rather console applications that communicate with a
    GUI such as XBoard (Linux) and WinBoard (Windows) via a standard
    protocol.
  \end{quote}

  In the web page for XBoard, we may read the following:
 \begin{quote}
    XBoard is a graphical user interface for chess [...]. It displays
    a chessboard on the screen, accepts moves made with the mouse, and
    loads and saves games in Portable Game Notation (PGN). It serves
    as a front-end for many different chess services, including:

    \begin{itemize}
    \item Chess engines that will run on your machine and play a game
      against you or help you analyze, such as GNU Chess, Crafty, or
      many others.
    \item [...]
    \end{itemize}
  \end{quote}
 
  Given the above information on XBoard, chess engines, and how they
  interact at runtime, which of the following architectural styles
  best represents the of architecture of a software system based on
  XBoard and one of the engines?

    \optionA{The \emph{Communicating Processes} style}
    \optionB{The \emph{Uses} style}
    \optionC{The \emph{Layers} style}
    \optionD{The \emph{Peer-to-Peer} style}

    \putOptions
\end{ClosedQuestion}
}


%11 
\newcommand{\qAlterarFuncionalidadesExistentes}{
\begin{ClosedQuestion}
  Suppose that you join the development team of a very large software
  system, and that you are assigned some tasks to change some existing
  features.  Which of the following architectural views would be, in
  principle, more useful to you to perform those tasks quickly?

    \optionA{\emph{Decomposition} and \emph{Layers} views}
    \optionB{\emph{Decomposition} and \emph{Work assignment} views}
    \optionC{\emph{Decomposition} and \emph{Implementation} views}
    \optionD{\emph{Decomposition} and \emph{Generalization} views}

    \putOptions
\end{ClosedQuestion}
}


%12
\newcommand{\qBlackBoxTesting}{
\begin{ClosedQuestion}
  Consider the following excerpt from the Wikipedia page on
  \emph{black-box testing}:
  \begin{quote}
    Black-box testing is a method of software testing that tests the
    functionality of an application as opposed to its internal
    structures or workings.  Specific knowledge of the application's
    code/internal structure and programming knowledge in general is
    not required.  Test cases are built around specifications and
    requirements, i.e., what the application is supposed to do.
  \end{quote}
  
  Assuming that you belong to the team testing a complex system and
  that you are responsible for performing black box tests on the
  system, which of the following architectural views of the system
  would be most useful to you?

    \optionA{\emph{Decomposition} and \emph{Implementation} views}
    \optionB{\emph{Decomposition} and \emph{Uses} views}
    \optionC{\emph{Component-and-connector} views}
    \optionD{ None, given that to perform black-box testing you do not
    need to know the code or the internal structure of the application
    to be tested}

    \putOptions
\end{ClosedQuestion}
}


%13
\newcommand{\qTrocarBDCamadas}{
\begin{ClosedQuestion}
  Consider an enterprise application that needs to keep its data
  persistently, but for which no one knows yet what is the volume of
  information that will be handled by the application.  Therefore, the
  system's architect intends to develop the system such that it is
  possible to change easily the relational database (RDBMS) component
  used to store the application's data, replacing it with an RDBMS
  from another manufacturer.  Given that this is a common requirement,
  the recommended software architecture for such applications fulfills
  this requirement by using a particular architectural style.  Which
  style is it?

    \optionA{The \emph{Shared data} style}
    \optionB{The \emph{Repository} style}
    \optionC{The \emph{Layers} style}
    \optionD{The \emph{Client-Server} style}

    \putOptions
\end{ClosedQuestion}
}


%14
\newcommand{\qGoogleAppEngine}{
\begin{ClosedQuestion}
  Suppose that you decided to use the Google App Engine (GAE) in the
  development of a web application.

  The GAE is described in the Wikipedia as follows:
  \begin{quote}
    Google App Engine is a platform for developing and hosting web
    applications in Google-managed data centers.

    Google App Engine is cloud computing technology.  It virtualizes
    applications across multiple servers and data centers. [...]

    Google App Engine is free up to a certain level of used resources.
    Fees are charged for additional storage, bandwidth, or CPU cycles
    required by the application.
  \end{quote}
  
  On the other hand, the GAE documentation reads the following:
  \begin{quote}
    With App Engine, you can build web applications using standard
    Java technologies and run them on Google's scalable
    infrastructure.  The Java environment provides a Java 6 JVM, a
    Java Servlets interface, and support for standard interfaces to
    the App Engine scalable datastore and services, such as JDO, JPA,
    JavaMail, and JCache.  Standards support makes developing your
    application easy and familiar, and also makes porting your
    application to and from your own servlet environment
    straightforward.
  \end{quote}

  Taking into account these two perspectives on the GAE, which
  architectural styles are more appropriate to represent the use of
  GAE in the software architecture of your web application?

    \optionA{The \emph{Decompostion} and \emph{Implementation} styles}
    \optionB{The \emph{Deployment} and \emph{Uses} styles}
    \optionC{The \emph{Client-Server} and \emph{Generalization} styles}
    \optionD{the \emph{Deployment} and \emph{Layers} styles}

    \putOptions
\end{ClosedQuestion}
}


%15
\newcommand{\qAumentarDesempenhoClienteServidor}{
\begin{ClosedQuestion}
  Suppose you have a system with a client-server architecture that was
  designed to support the simultaneous existence of at most 100
  clients, without specific requirements for availability.  The
  solution adopted and put into operation four years ago is a single
  server component to which all clients connect to.  This solution
  satisfies the initial requirements but with the recent increase in
  the maximum number of clients to 200, the system no longer has
  acceptable performance.  Not knowing anything else about the
  system's architecture, which solution do you propose to solve the
  system's performance problems?

    \optionA{To keep the current architecture of the system and optimize
    the code to achieve the currently required performance levels}
    \optionB{To change the Deployment view, replicating the server
    component by more machines}
    \optionC{To review the system's architecture so that part of the
    computation that is currently done at the server shifts to the
    clients}
    \optionD{To replace the machine used to run the server component by
    a more powerful machine that meets the new performance
    requirements, keeping only a server component running}

    \putOptions
\end{ClosedQuestion}
}


%16
\newcommand{\qAlteracaoWebDois}{
\begin{ClosedQuestion}
  The recent developments in web applications that made them provide a
  richer user interface led to a change in its architecture: part of
  the application's computation has to be done in the web browser used
  by users to access the application.  How is this change in the
  architecture manifested in the different types of views that
  describe the software architecture of a web application?

    \optionA{Given that the change is on execution aspects, the change
     manifests itself only through the modification of components and
     connectors on the system}
     \optionB{This change in the way of how web applications run
     does not correspond to any change in its architecture, because at
     the architectural level we still have the same components}
     \optionC{The only architectural change is on the Deployment view,
     because the components and connectors remain the same, but
     execute in different places}
     \optionD{This change manifests itself on the relationship between
     the system's modules and components}

    \putOptions
\end{ClosedQuestion}
}


%17
\newcommand{\qPluginsEclipse}{
\begin{ClosedQuestion}
  The Eclipse IDE is an open source application written in Java, and
  is extensible through the use of plug-ins.  In the document that
  describes the existing plug-ins architecture in Eclipse, we may read
  the following:

 \begin{quote}
    A plug-in in Eclipse is a component that provides a certain type
    of service within the context of the Eclipse workbench. [...]  The
    plug-in class provides configuration and management support for
    the plug-in.  A plug-in class in Eclipse must extend
    \texttt{org.eclipse.core.runtime.Plugin}, which is an abstract
    class that provides generic facilities for managing plug-ins.
  \end{quote}

  Considering the model and terminology used in the course to describe
  a software architecture, what kind of views are more appropriate to
  represent the plug-ins architecture of Eclipse described above?

    \optionA{Views of the Component-and-Connector viewtype}
    \optionB{Views of the Module viewtype}
    \optionC{Views of the Allocation viewtype}
    \optionD{All of the above}

    \putOptions
\end{ClosedQuestion}
}


%18
\newcommand{\qServiceLayer}{
\begin{ClosedQuestion}
  When someone uses the Domain Model pattern to implement the domain
  logic layer of an enterprise application, it is common to use also
  the Service Layer pattern. The Service Layer pattern is used in
  these cases

    \optionA{To control and to reduce the interface exposed by the
    domain logic layer, thereby increasing the modifiability of that
    layer}
    \optionB{To allow the existence of more than one layer of
    presentation logic for the same application (to provide for
    example, an interface to web services)}
    \optionC{To expose different interfaces of the domain logic layer
    so that it allows the implementation of different layers for the
    presentation logic}
    \optionD{To facilitate the use of the data access layer by the
    presentation logic layer}

    \putOptions
\end{ClosedQuestion}
}


%19
\newcommand{\qUnitOfWork}{
\begin{ClosedQuestion}
  The Unit of Work pattern is often used in enterprise applications 

    \optionA{To implement each of the services that are executed
    whenever the client makes a request to the server}
    \optionB{To improve the server performance by maintaining a cache
    of the objects most accessed during the processing of a client request}
    \optionC{To split the computation required to process each request
    made by the client in smaller units of work that are parallelizable}
    \optionD{To keep a record of changes made to the data during
     a business transaction and to coordinate the writing of these
     changes to the database}

    \putOptions
\end{ClosedQuestion}
}


%20
\newcommand{\qIdentityMap}{
\begin{ClosedQuestion}
  The Identity Map pattern is typically used in enterprise
  applications
 
    \optionA{To improve the performance of the application server because it
     maintains a cache of entities that reduces the number of operations
     made on the database}
     \optionB{To avoid loading a lot of data from the database when an
     entity that has many relationships with other entities is loaded}
     \optionC{To prevent data inconsistencies when there are
     multiple accesses within the same business operation to the same
     entity}
     \optionD{To map each entity loaded by the server to the identity
     of that entity in the database, so that the server is able to
     update the database later, if needed}

    \putOptions
\end{ClosedQuestion}
}






{\Large 
  \textbf{Atenção:} Nas perguntas que se seguem existem excertos de
  texto que foram obtidos directamente de fontes disponíveis na
  Internet (como a Wikipedia, por exemplo), sem alteração da
  terminologia usada para a adaptar à usada na cadeira.  Por isso,
  \textbf{pode acontecer que a terminologia usada nesses excertos de
    texto seja diferente da usada na cadeira.  Por exemplo, o uso de
    \emph{component} para referir outro tipo de elemento de software.
    Tenha isso em linha de conta nas suas respostas.}

}



%1
\newcommand{\qPorqueSepararComponentes}{
\begin{ClosedQuestion}
  Suponha que ao conceber a arquitectura de software de um sistema, um
  arquitecto decidiu particionar o sistema em três componentes, cada
  um dos quais com um conjunto de funcionalidades diferentes.  Qual
  das seguintes razões lhe parece mais adequada para justificar esta
  decisão?


    \optionA{Porque assim se pode fazer o desenvolvimento do sistema de
      forma incremental, em três etapas claramente separadas}
    \optionB{Porque assim é mais fácil modificar cada uma das três
      funcionalidades sem afectar as outras funcionalidades do sistema}
    \optionC{Porque existem requisitos de desempenho diferentes para
    cada um dos três tipos de funcionalidades, e esta solução permite
    controlar melhor o desempenho de cada um}
    \optionD{Porque esta solução permite o desenvolvimento do sistema
    em paralelo por três equipas diferentes, que apenas precisam de
    acordar entre si qual a interface de cada um dos componentes}
 \putOptions
\end{ClosedQuestion}
}


%2
\newcommand{\qArqChrome}{
\begin{ClosedQuestion}
  O Chromium é um navegador da web (\emph{web browser}), que
  introduziu uma arquitectura inovadora na forma como lida com a
  navegação simultânea de várias páginas, cada uma das quais numa
  \emph{tab} diferente do navegador.  No documento que descreve a
  arquitectura do Chromium, podemos ler o seguinte:

  \begin{quote}
    We use separate processes for browser tabs to protect the overall
    application from bugs and glitches in the rendering engine.  We
    also restrict access from each rendering engine process to others
    and to the rest of the system.  In some ways, this brings to web
    browsing the benefits that memory protection and access control
    brought to operating systems.

    We refer to the main process that runs the UI and manages tab and
    plugin processes as the "browser process" or "browser."  Likewise,
    the tab-specific processes are called "render processes" or
    "renderers."  The renderers use the WebKit open-source layout
    engine for interpreting and laying out HTML.
  \end{quote}

  Tendo em conta esta breve descrição da arquitectura de software do
  Chromium, que estilo arquitectural lhe parece mais adequado para a
  representar?


    \optionA{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Utilização (\emph{Uses})}
  \putOptions
\end{ClosedQuestion}
}


%3
\newcommand{\qChromeMultiPlatform}{
\begin{ClosedQuestion}
  Considerando ainda o exemplo do Chromium, encontra-se na página do
  projecto um outro documento intitulado ``Conventions and patterns
  for multi-platform development,'' onde se pode ler o seguinte:

  \begin{quote}
    Chromium is a large and complex cross-platform product.  We try to
    share as much code as possible between platforms, while
    implementing the UI and OS integration in the most appropriate way
    for each.  While this gives a better user experience, it adds
    extra complexity to the code.  This document describes the
    recommended practices for keeping such cross-platform code clean.

    We use a variety of different file naming suffixes to indicate
    when a file should be used:
    \begin{itemize}
    \item Windows files use the \texttt{\_win} suffix.
    \item Cocoa (Mac UI) files use the \texttt{\_cocoa} suffix, and lower-level Mac files use the \texttt{\_mac} suffix.
    \item Linux files use \texttt{\_linux} for lower-level files, \texttt{\_gtk} for GTK-specific files, and \texttt{\_x} for X Windows (with no GTK) specific files.
    \item Posix files shared between Mac and Linux use the \texttt{\_posix} suffix.
    \item Files for Chrome's ``Views'' UI (on Windows and experimental GTK) layout system use the \texttt{\_views} suffix.
   \end{itemize}

    The separate front-ends of the browser are contained in their own directories:
    \begin{itemize}
    \item Windows Views (and the experimental GTK-views): \\
      \texttt{chrome/browser/ui/views}
    \item Linux GTK: \texttt{chrome/browser/gtk}
    \item Mac: \texttt{chrome/browser/cocoa}
    \end{itemize}
  \end{quote}
  
  Novamente, tendo em conta esta breve descrição, que estilo
  arquitectural lhe parece mais adequado para a representar?


    \optionA{O estilo Implementação (\emph{Implementation})}
    \optionB{O estilo Atribuição de Trabalho (\emph{Work assignment})}
    \optionC{O estilo Decomposição (\emph{Decomposition})}
    \optionD{Nenhum, visto que esta descrição não tem nada a ver com a
    arquitectura do sistema}
  \putOptions
\end{ClosedQuestion}
}


%4
\newcommand{\qWebkit}{
\begin{ClosedQuestion}
  Na descrição da arquitectura do Chromium é dito que os
  \emph{renderers} usam o WebKit, que é descrito na Wikipedia da
  seguinte forma:

  \begin{quote}
    WebKit is a layout engine designed to allow web browsers to render
    web pages.  WebKit powers Google Chrome and Apple's Safari, the
    third and fourth most widely used web browsers respectively.  The
    WebKit engine provides a set of classes to display web content in
    windows, and implements browser features such as following links
    when clicked by the user, managing a back-forward list, and
    managing a history of pages recently visited.  
  
    WebKit was originally created as a fork of KHTML as the layout
    engine for Apple's Safari; it is portable to many other computing
    platforms.  Mac OS X and Windows are supported by the project.

    WebKit's WebCore and JavaScriptCore components are available under
    the GNU Lesser General Public License, and the rest of WebKit is
    available under a BSD-style license.
  \end{quote}
  
  Suponha que vai desenvolver um novo \emph{browser} e que decidiu
  usar o WebKit para suportar o \emph{rendering} das páginas de HTML,
  à semelhança do que é feito no Chromium e no Safari.  Qual das
  seguintes vistas arquitecturais é mais adequada para representar
  esta decisão?


    \optionA{A vista de Decomposição (\emph{Decomposition})}
    \optionB{As vistas do tipo Componente-e-Conector }
    \optionC{A vista de Atribuição de Trabalho (\emph{Work Assignment})}
    \optionD{A vista de Utilização (\emph{Uses})}
  \putOptions
\end{ClosedQuestion}
}


%5
\newcommand{\qArqEmailMUA}{
\begin{ClosedQuestion}
  O sistema de email é composto por vários tipos de componentes que
  desempenham diferentes funções.  Por exemplo, para enviar um email,
  um utilizador pode utilizar um programa como o Microsoft Outlook ou
  o Mozilla Thunderbird, genericamente designado por \emph{mail user
    agent} (MUA), para compor a sua mensagem e enviá-la.  Para enviar
  a mensagem, tipicamente o MUA liga-se a um \emph{mail transfer
    agent} (MTA), que recebe a mensagem, analisa os cabeçalhos da
  mesma para determinar os vários destinatários e, após consulta do
  sistema DNS para determinar quais os MTA responsáveis por cada um
  dos destinatários, liga-se aos MTAs responsáveis pelos endereços de
  destino para entregar a mensagem.  Cada um desses MTAs recebe a
  mensagem e armazena-a localmente ou reenvia-a para outros MTAs até
  que a mensagem chegue ao MTA do destino.  O utilizador destinatário
  da mensagem irá depois usar o seu MUA para ver as mensagens que lhe
  foram enviadas.

  Tendo em conta esta descrição simplificada do funcionamento do
  sistema de email, qual das seguintes descrições lhe parece mais
  adequada para representar a arquitectura de software do sistema de
  email, se apenas estivermos interessados no padrão de interacção
  existente entre os MUAs?


    \optionA{O padrão de interacção existente entre os MUAs corresponde
    ao estilo arquitectural Par-a-Par (\emph{Peer-to-Peer})}
    \optionB{O padrão de interacção existente entre os MUAs corresponde
    ao estilo arquitectural Cliente-Servidor (\emph{Client-Server})}
    \optionC{O padrão de interacção existente entre os MUAs corresponde
    ao estilo arquitectural \emph{Blackboard}}
    \optionD{O padrão de interacção existente entre os MUAs corresponde
    ao estilo arquitectural Publicação-Subscrição
    (\emph{Publish-subscribe}), sendo que os MTAs e DNS implementam o
    conector }
 \putOptions
\end{ClosedQuestion}
}


%6
\newcommand{\qCamadasParaCloudComputing}{
\begin{ClosedQuestion}
  Suponha que vai desenvolver uma aplicação web que pretende alojar
  numa das várias plataformas de \emph{Cloud Computing} actualmente
  existentes.  Para isso, analisou as várias ofertas disponíveis, e
  seleccionou um subconjunto de plataformas que providenciam um
  conjunto de serviços semelhantes (por exemplo, serviços de
  armazenamento de dados, serviços de mensagens, etc), mas que o fazem
  usando interfaces diferentes.  Por isso, para desenvolver o seu
  sistema acaba por escolher uma dessas plataformas, mas, para evitar
  ficar preso a essa escolha, coloca como requisito para o seu sistema
  que este seja facilmente portável para outra plataforma semelhante à
  que escolheu.  Que solução arquitectural melhor satisfaz este
  requisito?

   
    \optionA{A criação de um módulo na decomposição do sistema que
    represente a plataforma escolhida, módulo este que poderá ser
    alterado posteriormente quando se trocar de plataforma}
    \optionB{A arquitectura padrão para aplicações empresariais,
    composta pelas três camadas de ``Lógica de apresentação,''
    ``Lógica de domínio,'' e ``Acesso a dados''}
    \optionC{A criação de um módulo genérico com os serviços comuns a
    todas as plataformas, módulo este que é depois especializado
    por módulos específicos para cada plataforma}
    \optionD{Uma arquitectura de camadas em que a camada mais de baixo
    providencia uma interface que é uma abstracção dos serviços
    fornecidos pelas várias plataformas}
 \putOptions
\end{ClosedQuestion}
}


%7
\newcommand{\qVistasParaReplicacao}{
\begin{ClosedQuestion}
  A replicação é uma das tácticas mais usadas para satisfazer
  requisitos de disponibilidade como, por exemplo, o requisito de que
  uma aplicação web deve continuar a funcionar normalmente, mesmo
  quando existe uma falta ao nível do seu servidor web.  A utilização
  da táctica de replicação do servidor web reflecte-se em que vistas
  da arquitectura de software?

  
    \optionA{Em ambas as vistas componente-e-conector e Instalação
    (\emph{Deployment}), visto que cada uma delas aborda um aspecto
    diferente da concretização da táctica de replicação}
    \optionB{Apenas na vista de componente-e-conector que inclui o
    servidor web}
    \optionC{Apenas na vista de Instalação (\emph{Deployment}), visto
    que a utilização desta táctica não altera os componentes, mas sim
    onde é que eles executam}
   \optionD{A utilização dessa táctica não altera nenhuma das vistas
    da arquitectura de uma aplicação web, visto que a arquitectura
    padrão para este tipo de aplicações já suporta, de raiz, a
    replicação do servidor web}
  \putOptions
\end{ClosedQuestion}
}


%8
\newcommand{\qVistasNecessarias}{
\begin{ClosedQuestion}
  De acordo com o modelo do SEI, existem apenas três tipos diferentes
  de vistas arquitecturais que são suficientes para descrever qualquer
  arquitectura de software.  Isto significa que, para se descrever a
  arquitectura de software de um sistema, qualquer que ele seja

  
    \optionA{É necessário ter exactamente uma vista de cada um destes
    três tipos de vistas}
    \optionB{Apenas se usa uma vista de um destes três tipos, embora
    outros sistemas possam usar vistas de tipos diferentes}
    \optionC{É necessário ter pelo menos uma vista de cada um destes
    três tipos de vistas, mas podemos ter mais do que uma vista de
    cada tipo}
    \optionD{Podemos ter zero ou mais vistas de qualquer um dos três
    tipos de vista}
 \putOptions
\end{ClosedQuestion}
}



%9
\newcommand{\qImportanciaStakeholders}{
\begin{ClosedQuestion}
  No Ciclo de Negócio da Arquitectura uma das principais influências
  na arquitectura de um sistema de software são os seus
  \emph{stakeholders}, porque

  
    \optionA{O arquitecto tem que descrever a arquitectura do sistema
    de forma a que todos os stakeholders compreendam o funcionamento
    do sistema}
    \optionB{Os stakeholders financiam o desenvolvimento do sistema e,
    portanto, ao estabelecerem o orçamento disponível, influenciam a
    arquitectura do sistema}
    \optionC{Os stakeholders são a fonte dos requisitos funcionais do sistema}
    \optionD{Os stakeholders são a principal fonte dos requisitos
    funcionais e de qualidade do sistema}
  \putOptions
\end{ClosedQuestion}
}


%10
\newcommand{\qGerirEquipaManutencao}{
\begin{ClosedQuestion}
  Após o desenvolvimento de todas as funcionalidades pedidas para um
  sistema de software e da sua entrada em produção, é normal que a
  maior parte da equipa envolvida no desenvolvimento desse sistema
  seja posta a trabalhar no desenvolvimento de outros sistemas.  No
  entanto, é normal que surjam com alguma frequência pedidos de
  alteração de funcionalidades do sistema em produção (correspondendo
  à sua fase de manutenção evolutiva).
  
  Suponha que foi contratado para fazer a gestão desses pedidos de
  alteração, planeando a sua execução (que será feita pelos
  programadores da equipa de desenvolvimento e não por si) tendo em
  conta, entre outros factores, a disponibilidade dos membros da
  equipa de desenvolvimento.  Quais das seguintes vistas
  arquitecturais lhe seriam, em princípio, mais úteis para desempenhar
  o seu trabalho?

  
    \optionA{Vistas de Decomposição (\emph{Decomposition}) e de Camadas (\emph{Layers})}
    \optionB{Vistas de Decomposição (\emph{Decomposition}) e de
    Atribuição de Trabalho (\emph{Work assignment})}
    \optionC{Vistas de Decomposição (\emph{Decomposition}) e de Implementação (\emph{Implementation})}
    \optionD{Vistas de Decomposição (\emph{Decomposition}) e de Generalização (\emph{Generalization})}
  \putOptions
\end{ClosedQuestion}
}


%11
\newcommand{\qAumentarDesempenhoClienteServidor}{
\begin{ClosedQuestion}
  Suponha que desenvolveu uma aplicação web que permite aos seus
  utilizadores jogarem Xadrez uns contra os outros.  A aplicação
  permite que os jogadores se juntem em pares para realizarem um jogo,
  após o que o jogo decorre entre esses dois jogadores durante algum
  tempo até ao fim do jogo.  Um jogo completo pode demorar desde cerca
  de 1 hora, até vários dias, dependendo do tempo que cada jogador
  demora a realizar uma jogada.  Este sistema foi concebido como uma
  aplicação web tradicional, e tem estado a funcionar já há alguns
  meses com um único componente do tipo servidor ao qual se ligam
  todos os clientes web.  No entanto, dada a recente exposição
  mediática do seu jogo, o número de utilizadores da sua aplicação
  aumentou substancialmente nos últimos tempos.  De facto, viu o seu
  sistema passar rapidamente dos habituais 10 pedidos simultâneos que
  eram processados com um tempo médio de resposta inferior a 300 ms,
  para 100 pedidos a serem processados simultaneamente com um tempo
  médio de resposta de cerca de 5 segundos.  Na realidade, o número de
  pedidos simultâneos não aumentou mais porque o seu servidor rejeita
  pedidos adicionais assim que atinge os 100 pedidos em processamento.

  Visto que as expectativas é que a utilização do sistema continue a
  aumentar, podendo mesmo chegar aos 10000 pedidos simultâneos, e que
  o sistema só é utilizável se tiver tempos médios de resposta abaixo
  dos 2 segundos, que solução propõe para resolver os problemas de
  desempenho do sistema?

  
    \optionA{Manter a arquitectura actual do sistema e optimizar o
    código de modo a alcançar os níveis de desempenho necessários actualmente}
    \optionB{Utilizar uma táctica de introdução de concorrência de
    forma a que possam existir mais servidores a processar pedidos}
    \optionC{Utilizar uma táctica de replicação activa de forma a que
    se consiga obter respostas com um tempo médio de resposta mais baixo}
    \optionD{Substituir a máquina usada pelo servidor por uma máquina
    mais poderosa que satisfaça os novos requisitos de desempenho,
    mantendo apenas um componente servidor em funcionamento}
  \putOptions
\end{ClosedQuestion}
}


%12
\newcommand{\qPluginsEclipse}{
\begin{ClosedQuestion}
  O IDE Eclipse é uma aplicação \emph{open source} escrita em Java, e
  é extensível através da utilização de \emph{plug-ins}.  No documento
  que descreve a arquitectura de plug-ins existente no Eclipse,
  podemos ler o seguinte:

  \begin{quote}
    A plug-in in Eclipse is a component that provides a certain type
    of service within the context of the Eclipse workbench. [...] The
    Eclipse runtime provides an infrastructure to support the
    activation and operation of a set of plug-ins working together to
    provide a seamless environment for development activities. Within
    a running Eclipse instance, a plug-in is embodied in an instance
    of some plug-in runtime class, or plug-in class, for short. 
    
    [...]

    Such a plug-in can then be activated by the Eclipse runtime when
    it is required to perform some function.  Activating a plug-in
    means loading its runtime class and instantiating and initializing
    its instance.

    The main function of a plug-in class is to do special processing
    during plug-in activation and deactivation, e.g., to allocate and
    release resources.
  \end{quote}

  Tendo em conta o modelo e a nomenclatura usados na cadeira para a
  descrição de uma arquitectura de software, que tipo de vistas lhe
  parecem mais adequadas para representar a arquitectura de plug-ins
  do Eclipse descrita acima?

  
    \optionA{Vistas do tipo de vista componente-e-conector}
    \optionB{Vistas do tipo de vista módulo}
    \optionC{Vistas do tipo de vista afectação (\emph{Allocation})}
    \optionD{Todas as anteriores}
  \putOptions
\end{ClosedQuestion}
}


%13
\newcommand{\qUsesAMais}{
\begin{ClosedQuestion}
  Suponha que no processo de desenho da arquitectura de software de um
  sistema chega à conclusão de que existem ciclos na relação de
  utilização (\emph{uses}) entre os módulos do sistema, fazendo com
  que quase todos os módulos do sistema dependam da maior parte dos
  restantes módulos.  Como é que resolveria este problema?

  
    \optionA{Eliminava algumas das relações de utilização para quebrar
    os ciclos}
    \optionB{Voltava ao estilo decomposição (\emph{decomposition}) para
    decompor o sistema de outra forma, de modo a que não surjam ciclos
    no estilo de utilização}
    \optionC{Substituía algumas das relações de utilização por relações
    de generalização (\emph{generalization}) de modo a quebrar os
    ciclos}
    \optionD{A existência de ciclos ou de muitas relações de utilização
    não é um problema que precise de ser resolvido}
  \putOptions
\end{ClosedQuestion}
}


%14
\newcommand{\qRelacaoComponentsDeployment}{
\begin{ClosedQuestion}
  Qual é a relação existente entre os elementos de hardware
  correspondentes a unidades de processamento (máquinas) numa vista do
  estilo Instalação (\emph{Deployment}) e os componentes de um
  sistema, considerando que réplicas do mesmo componente contam como
  componentes diferentes?

  
    \optionA{O número de elementos de hardware tem que ser igual ao
    número de componentes}
    \optionB{O número de elementos de hardware tem que ser menor ou
    igual ao número de componentes}
    \optionC{O número de elementos de hardware tem que ser maior ou
    igual ao número de componentes}
    \optionD{Não existe qualquer restrição quanto ao número de
    elementos de hardware}
  \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qMashups}{
\begin{ClosedQuestion}
  Uma das evoluções no desenvolvimento de aplicações web foi a criação
  de \emph{mashups}, que são descritas na Wikipedia da seguinte forma:

  \begin{quote}
    In web development, a mashup is a web page or application that
    uses and combines data, presentation or functionality from two or
    more sources to create new services.
  \end{quote}

  Embora existam várias formas de implementar e providenciar estes
  mashups, uma abordagem comum é passar para o \emph{browser} a
  responsabilidade de contactar os vários serviços que se pretende
  combinar e de processar as suas respostas, implementando assim o
  \emph{mashup}.

  Que estilo arquitectural melhor descreve o funcionamento deste tipo
  de aplicações?

  
    \optionA{O estilo Dados partilhados (\emph{Shared data})}
    \optionB{O estilo Repositório (\emph{Repository})}
    \optionC{O estilo Camadas (\emph{Layers})}
    \optionD{O estilo Cliente-Servidor (\emph{Client-Server})}
  \putOptions
\end{ClosedQuestion}
}



%16
\newcommand{\qDisponibilidadeRetalhix}{
\begin{ClosedQuestion}
  O sistema Retalhix é um sistema que permite fazer a gestão dos
  produtos e das vendas dos hipermercados, incluindo o funcionamento
  das caixas por onde os clientes passam para registar e pagar as suas
  compras.  Considere o seguinte requisito de disponibilidade para o
  Retalhix

  \begin{quote}
    O aspecto mais crítico para o funcionamento de uma loja é a
    correcta operação das caixas, visto que o não funcionamento das
    caixas afecta directamente os clientes e a sua possibilidade de
    comprar produtos.
  \end{quote}

 Supondo que o que se pretende é que, em caso de falta (qualquer que
  ela seja) de uma só caixa, o cliente que estava a ser atendido nessa
  caixa possa à mesma pagar as suas compras e sair da loja com elas,
  como é que a arquitectura do sistema pode dar resposta a este
  requisito?

  
    \optionA{Criando mecanismos que permitam, em primeiro lugar,
    detectar falhas numa caixa e, uma vez detectada uma falha, reparar a
    falha rapidamente para que a caixa volte a operar normalmente}
    \optionB{Prevendo nas vistas de componente-e-conector e na de
    instalação (\emph{deployment}) a execução de pelo menos um
    componente redundante em cada caixa, para evitar que existam
    falhas nas caixas}
    \optionC{Mostrando na vista de instalação (\emph{deployment}) que
    num hipermercado existem várias caixas em funcionamento em cada
    instante, pelo que já existe redundância ao nível do hardware para
    satisfazer este requisito}
    \optionD{Replicando os servidores que são contactados pelas caixas,
    e colocando um \emph{load balancer} entre as caixas e os
    servidores}
  \putOptions
\end{ClosedQuestion}
}

%17
\newcommand{\qDisponibilidadeRetalhixMeioDasCompras}{
\begin{ClosedQuestion}
  Considerando ainda o sistema Retalhix da pergunta anterior, imagine
  a situação em que um cliente tem dois carrinhos de supermercado
  cheios de compras e vai a meio do registo das suas compras na caixa
  quando esta falha.  Suponha que o que se pretende neste cenário é
  que se possa continuar a registar os produtos do cliente sem ter que
  voltar a registar os produtos já registados.  Que consequências é
  que este novo requisito tem na arquitectura do sistema?

  
    \optionA{Não tem nenhuma}
    \optionB{Reflecte-se apenas ao nível da vista de instalação
    (\emph{deployment})}
    \optionC{Reflecte-se apenas ao nível das vistas do tipo de vista módulo}
    \optionD{Pode reflectir-se não só ao nível das funcionalidades do
    sistema, como ainda ao nível das vistas componente-e-conector e instalação
    (\emph{deployment})}
  \putOptions
\end{ClosedQuestion}
}


%18
\newcommand{\qRelacaoModulosComponentes}{
\begin{ClosedQuestion}
  Qual das seguintes frases descreve melhor a relação existente entre
  módulos e componentes?

  \optionA{Um módulo pode conter código de diferentes componentes}
  \optionB{Um componente pode executar código de módulos diferentes}
  \optionC{Um módulo pode executar código de componentes diferentes}
  \optionD{Um componente pode conter código de diferentes módulos}
  \putOptions
\end{ClosedQuestion}
}



%19
\newcommand{\qIdentityMap}{
\begin{ClosedQuestion}
  O padrão Identity Map é usado em aplicações empresariais

  
    \optionA{Quando a lógica de domínio da aplicação é implementada
    recorrendo ao padrão Transaction Script que acede aos dados persistentes através de Record Sets}
    \optionB{Quando a lógica de domínio da aplicação é implementada
    recorrendo ao padrão Domain Model }
    \optionC{Quando a lógica de domínio da aplicação é implementada
    recorrendo ao padrão Service Layer}
    \optionD{Independentemente de qual é a forma usada para implementar
    a lógica de domínio da aplicação}
  \putOptions
\end{ClosedQuestion}
}



%20
\newcommand{\qUnitOfWork}{
\begin{ClosedQuestion}
  O padrão Unit of Work é normalmente usado em aplicações empresariais
  para agrupar uma série de operações de acesso a dados que pertencem
  a uma única operação de negócio.  Visto que o código executado no
  contexto de uma Unit of Work pode estar espalhado por diferentes
  módulos do sistema, pode acontecer que durante a mesma Unit of Work
  se leia da base de dados os mesmos dados mais do que uma vez, o que
  pode trazer problemas de coerência da informação se não forem
  tomadas as precauções devidas.  Como é que este problema é resolvido
  quando se está a usar o padrão Unit of Work?

  
    \optionA{Uma vez que o padrão Unit of Work coordena as escritas na
    base de dados, consegue detectar quando é que os dados podem ficar
    incoerentes, e aborta a operação nesses casos}
   \optionB{Cada Unit of Work utiliza um Identity Map para evitar este
    problema}
    \optionC{Visto que todas as operações de acesso a dados feitas no
    contexto de uma Unit of Work são feitas na mesma transacção de
    base de dados, a base de dados garante a coerência dos dados}
    \optionD{Este problema não é resolvido pelo Unit of Work, e é uma
    das desvantagens da sua utilização, porque é o programador que tem
    que lidar com o problema directamente no código que escreve}
  \putOptions
\end{ClosedQuestion}
}

